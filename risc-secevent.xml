<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type='text/xsl' href='http://xml2rfc.tools.ietf.org/authoring/rfc2629.xslt' ?>
<!DOCTYPE rfc PUBLIC "-//IETF//DTD RFC 2629//EN" "http://xml2rfc.tools.ietf.org/authoring/rfc2629.dtd">
<!--
  NOTE:  This XML file is input used to produce the authoritative copy of an
  OpenID Foundation specification.  The authoritative copy is the HTML output.
  This XML source file is not authoritative.  The statement ipr="none" is
  present only to satisfy the document compilation tool and is not indicative
  of the IPR status of this specification.  The IPR for this specification is
  described in the "Notices" section.  This is a public OpenID Foundation
  document and not a private document, as the private="..." declaration could
  be taken to indicate.
-->

<rfc docName="risc-secevent-00" category="std" ipr="none">

  <?rfc toc="yes" ?>
  <?rfc tocdepth="5" ?>
  <?rfc symrefs="yes" ?>
  <?rfc sortrefs="yes"?>
  <?rfc strict="yes" ?>
  <?rfc iprnotified="no" ?>
  <?rfc private="Draft" ?>
  <?rfc comments="yes"?>

  <front>
    <title abbrev="risc-secevent">RISC profile of IETF Security Events</title>

    <author initials="M." surname="Scurtescu" fullname="Marius Scurtescu">
      <organization abbrev="Google">Google</organization>
      <address>
        <email>mscurtescu@google.com</email>
      </address>
    </author>
    <author initials="A." surname="Backman" fullname="Annabelle Backman">
      <organization abbrev="Amazon">Amazon</organization>
      <address>
        <email>richanna@amazon.com</email>
      </address>
    </author>
    <author initials="P." surname="Hunt" fullname="Phil Hunt">
      <organization abbrev="Oracle">Oracle Corporation</organization>
      <address>
        <email>phil.hunt@yahoo.com</email>
      </address>
    </author>
    <author initials="J." surname="Bradley" fullname="John Bradley">
      <organization abbrev="Yubico">Yubico</organization>
      <address>
        <email>secevemt@ve7jtb.com</email>
      </address>
    </author>

    <date year="2018" month="January" day="31"/>

    <workgroup>RISC Working Group</workgroup>

    <abstract>
      <t>This spec is a general profile for <xref target="SECEVENT">IETF Security Events</xref>
        and it defines:<list style="symbols">
        <t>Subject Identifiers</t>
        <t>a configuration information discovery method for Transmitters</t>
        <t>a Management API for Event Streams</t>
      </list></t>

      <t>This spec also directly profiles several IETF Security Events drafts:<list style="symbols">
          <t><xref target="SET">Security Event Token (SET)</xref></t>
          <t><xref target="DELIVERY">SET Token Delivery Using HTTP</xref></t>
        </list></t>
    </abstract>
  </front>

  <middle>
    <section anchor="intro" title="Introduction">
      <section anchor="conv" title="Notational Conventions">
        <t>The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD
          NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as
          described in <xref target="RFC2119"/>.</t>
      </section>
    </section>

    <section anchor="subject-ids" title="Subject Identifiers">
      <t>The RISC profile defines a structure called a Subject Identifier: a <xref target="RFC7159">JSON</xref>
        object containing a set of claims that collectively uniquely identify a subject, according 
        to a simple schema called a Subject Identifier Type. Every Subject Identifier MUST contain 
        a <spanx style="verb">subject_type</spanx> claim, whose value MUST be a name that uniquely 
        identifies the Subject Identifier Type of the Subject Identifier. Any remaining claims 
        within the Subject Identifier MUST be interpreted according to the definition of the 
        Subject Identifier Type. A Subject Identifier MUST conform to the Subject Identifier Type 
        identified by its <spanx style="verb">subject_type</spanx> claim, and MUST NOT contain any 
        claims not defined by its Subject Identifier Type.</t>

      <figure anchor="subject-ids-ex-email" title="Example: Email Subject Identifier">
        <artwork><![CDATA[
{
  "subject_type": "email",
  "email": "foo@example.com"
}
        ]]></artwork>
        <postamble>A Subject Identifier that identifies a subject by email address.</postamble>
      </figure>

      <figure anchor="subject-ids-ex-iss-sub" title="Example: Issuer and Subject Subject Identifier">
        <artwork><![CDATA[
{
  "subject_type": "iss-sub",
  "iss": "https://issuer.example.com/",
  "sub": "abc1234"
}
        ]]></artwork>
        <postamble>A Subject Identifier that identifies a subject by an identifier provided by an
          issuer.</postamble>
      </figure>

      <section anchor="sub-id-types" title="Subject Identifier Types">
        <t>A Subject Identifier Type is a light-weight schema that describes a set of claims that
          uniquely identifies a subject. Every Subject Identifier Type MUST have a unique name
          registered in the IANA "RISC Subject Identifier Types" registry established by <xref
            target="iana-sub-id-types"/>. A Subject Identifier Type MAY contain more claims than are
          strictly necessary to uniquely identify a subject, however a Subject Identifier MUST
          contain all of the claims required by its type (See <xref target="privacy" format="title"/>).</t>

        <t> The following Subject Identifier Types are registered in the IANA "RISC Subject
          Identifier Types" registry established by <xref target="iana-sub-id-types"/>.</t>

        <section anchor="sub-id-email" title="Email Subject Identifier Type">
          <t>The Email Subject Identifier Type describes a subject by email address. Subject
            Identifiers of this type MUST contain an <spanx style="verb">email</spanx> claim whose value is a string
            containing the email address of the subject. The <spanx style="verb">email</spanx> claim MUST NOT be null or
            empty. The Email Subject Identifier Type is identified by the name <spanx style="verb">email</spanx>.</t>
        </section>

        <section anchor="sub-id-phone" title="Phone Number Subject Identifier Type">
          <t>The Phone Number Subject Identifier Type describes a subject by telephone number.
            Subject Identifiers of this type MUST contain a <spanx style="verb">phone</spanx> claim whose value is a string
            containing the full telephone number of the subject, including international dialing
            prefix, formatted according to <xref target="E164">E.164</xref>. The <spanx style="verb">phone</spanx> claim MUST
            NOT be null or empty. The Phone Number Subject Identifier Type is identified by the name
            <spanx style="verb">phone</spanx>.</t>
        </section>

        <section anchor="sub-id-iss-sub" title="Issuer and Subject Subject Identifier Type">
          <t>The Issuer and Subject Subject Identifier Type describes a subject by an issuer and a
            subject. Subject Identifiers of this type MUST contain an <spanx style="verb">iss</spanx> claim whose value
            identifies the issuer, and a <spanx style="verb">sub</spanx> claim whose value identifies the subject with respect
            to the issuer. These claims MUST follow the formats of the <spanx style="verb">iss</spanx> claim and <spanx style="verb">sub</spanx> claim
            defined by <xref target="RFC7519"/>, respectively. Both the <spanx style="verb">iss</spanx> claim and the <spanx style="verb">sub</spanx>
            claim MUST NOT be null or empty. The Issuer and Subject Subject Identifier Type is
            identified by the name <spanx style="verb">iss-sub</spanx>.</t>
        </section>

	<section anchor="sub-id-id-token-claims" title="ID Token Claims Subject Identifier Type">
          <t>The ID Token Claims Subject Identifier Type describes a subject by a subset of the claims from an ID token. Subject Identifiers of this type MUST contain at least one of the following claims:<list style="hanging">
            <t hangText="email"><vspace blankLines="0"/>An <spanx style="verb">email</spanx> claim, as defined in <xref target="IDTOKEN"/>.</t>
            <t hangText="phone_number"><vspace blankLines="0"/>An <spanx style="verb">phone_number</spanx> claim, as defined in <xref target="IDTOKEN"/>.</t>
            <t hangText="sub"><vspace blankLines="0"/>A <spanx style="verb">sub</spanx> claim, as defined in <xref target="RFC7519"/>.</t>
          </list></t>

          <t>If the Subject Identifier contains a <spanx style="verb">sub</spanx> claim, it MUST also contain an
          <spanx style="verb">iss</spanx> claim, as defined in <xref target="RFC7519"/>.  The ID Token Claims Subject Identifier Type is identified by the name <spanx style="verb">id-token-claims</spanx>.</t>
        </section>
      </section>
    </section>

    <section anchor="discovery" title="Transmitter Configuration Discovery">
      <t>This section defines a mechanism for Receivers to obtain Transmitter configuration 
      information.</t>
      
      <section anchor="discovery-meta" title="Transmitter Configuration Metadata">
        <t>Transmitters have metadata describing their configuration:<list style="hanging">
          <t hangText="issuer">REQUIRED. URL using the https scheme with no query or fragment component that the
            Transmitter asserts as its Issuer Identifier. This MUST be identical to the iss Claim value in
            Security Event Tokens issued from this Transmitter.</t>
          <t hangText="jwks_uri"> REQUIRED. URL of the Transmitter's <xref target="RFC7517">JSON Web Key Set</xref>
            document. This contains the signing key(s) the Receiver uses to validate signatures from the 
            Transmitter.</t>
          <t hangText="delivery_methods_supported"> RECOMMENDED. List of supported delivery method 
            URIs.</t>
          <t hangText="configuration_endpoint"> OPTIONAL. The URL of the Configuration Endpoint.</t>
          <t hangText="status_endpoint"> OPTIONAL. The URL of the Status Endpoint.</t>
          <t hangText="add_subject_endpoint"> OPTIONAL. The URL of the Add Subject Endpoint.</t>
          <t hangText="remove_subject_endpoint"> OPTIONAL. The URL of the Remove Subject Endpoint.</t>
          <t hangText="verification_endpoint"> OPTIONAL. The URL of the Verification Endpoint.</t>
        </list></t>
      </section>
      
      <section title="Obtaining Transmitter Configuration Information">
        <t>Using the Issuer as documented by the Transmitter, the Transmitter Configuration
        Information can be retrieved.</t>
        
        <t>Transmitters supporting Discovery MUST make a JSON document available at the path formed 
          by concatenating the string <spanx style="verb">/.well-known/risc-configuration</spanx> to the Issuer. The syntax and 
          semantics of <spanx style="verb">.well-known</spanx> are defined in <xref target="RFC5785"/> and apply to the Issuer value 
          when it contains no path component. <spanx style="verb">risc-configuration</spanx> MUST point to a JSON document 
          compliant with this specification and MUST be returned using the <spanx style="verb">application/json</spanx> content 
          type.</t>
        
        <section title="Transmitter Configuration Request">
          <t>A Transmitter Configuration Document MUST be queried using an HTTP
            <spanx style="verb">GET</spanx> request at the previously specified path.</t>
          
          <t>The Receiver would make the following request to the Issuer <spanx style="verb">https://tr.example.com</spanx>
            to obtain its Configuration information, since the Issuer contains no path component:
            <figure title="Example: Transmitter Configuration Request (without path)" anchor="figdiscoveryrequest">
              <artwork><![CDATA[
GET /.well-known/risc-configuration HTTP/1.1
Host: tr.example.com
]]></artwork>
            </figure>
          </t>
          
          <t>
            If the  Issuer value contains a path component, any terminating <spanx style="verb">/</spanx> MUST be
            removed before appending <spanx style="verb">/.well-known/risc-configuration</spanx>.
            The Receiver would make the following request to the Issuer <spanx style="verb">https://tr.example.com/issuer1</spanx>
            to obtain its Configuration information, since the Issuer contains a path component:
            <figure title="Example: Transmitter Configuration Request (with path)" anchor="figdiscoveryrequestpath">
              <artwork><![CDATA[
GET /issuer1/.well-known/risc-configuration HTTP/1.1
Host: tr.example.com
]]></artwork>
            </figure>
          </t>
          
          <t>
            Using path components enables supporting multiple issuers per host. This is required in some multi-tenant hosting 
            configurations. This use of <spanx style="verb">.well-known</spanx> is for supporting multiple issuers per host; 
            unlike its use in <xref target="RFC5785"/>, it does not provide general information about the host.
          </t>
        </section>
        
        <section title="Transmitter Configuration Response">
          <t>The response is a set of Claims about the Transmitter's configuration, including all necessary endpoints and
            public key location information. A successful response MUST use the 200 OK HTTP status code and return
            a JSON object using the <spanx style="verb">application/json</spanx> content type that contains a set of Claims 
            as its members that are a subset of the Metadata values defined in <xref target="discovery-meta"/>.
            Other Claims MAY also be returned.</t>
          
          <t>Claims that return multiple values are represented as JSON arrays. Claims with zero elements MUST be omitted 
            from the response.</t>
          
          <t>An error response uses the applicable HTTP status code value.</t>
          
          <t>
            <figure title="Example: Transmitter Configuration Response" anchor="figdiscoveryresponse">
              <artwork><![CDATA[
HTTP/1.1 200 OK
Content-Type: application/json

{
  "issuer":
    "https://tr.example.com",
  "jwks_uri":
    "https://tr.example.com/jwks.json",
  "delivery_methods_supported": [
    "http://schemas.openid.net/secevent/risc/delivery-method/push", 
    "http://schemas.openid.net/secevent/risc/delivery-method/poll"],
  "configuration_endpoint":
    "https://tr.example.com/risc/mgmt/stream",
  "status_endpoint":
    "https://tr.example.com/risc/mgmt/status",
  "add_subject_endpoint":
    "https://tr.example.com/risc/mgmt/subject:add",
  "remove_subject_endpoint":
    "https://tr.example.com/risc/mgmt/subject:remove",
  "verification_endpoint":
    "https://tr.example.com/risc/mgmt/verification",
}
]]></artwork>
            </figure>
          </t>
        </section>
        
        <section title="Transmitter Configuration Validation">
          <t>If any of the validation procedures defined in this specification fail, any operations requiring
            the information that failed to correctly validate MUST be aborted and the information that failed 
            to validate MUST NOT be used.</t>
          
          <t>The <spanx style="verb">issuer</spanx> value returned MUST be identical to the Issuer URL that 
            was directly used to retrieve the configuration information. This MUST also be identical to the 
            <spanx style="verb">iss</spanx> Claim value in Security Event Tokens issued from this Transmitter.
          </t>
        </section>
      </section>
    </section>
    
    <section anchor="management" title="Management API for SET Event Streams">
      <t>This section defines an HTTP API to be implemented by Event Transmitters
        and that can be used by Event Receivers to query the Event Stream status, to
        add and remove subjects and to trigger verification.</t>
      
      <t>This section is based on <xref target="MGMTAPI">Management API for SET Event Streams</xref>.</t>
      
      <figure title="Event Stream Management API" anchor="figintro"><artwork><![CDATA[
+------------+                +------------+
|            | Stream Config  |            |
| Event      <----------------+ Event      |
| Stream     |                | Receiver   |
| Management | Stream Status  |            |
| API        <----------------+            |
|            |                |            |
|            | Add Subject    |            |
|            <----------------+            |
|            |                |            |
|            | Remove Subject |            |
|            <----------------+            |
|            |                |            |
|            | Verification   |            |
|            <----------------+            |
|            |                |            |
+------------+                +------------+
]]></artwork></figure>
      
      <section anchor="management-api" title="Event Stream Management">
        <t>Event Receivers manage how they receive events, and the subjects about which they want
          to receive events over an Event Stream by making HTTP requests to endpoints in the Event
          Stream Management API.</t>

        <t>The Event Stream Management API is implemented by the Event Transmitter and consists of
          the following endpoints:</t>

        <t><list style="hanging">
            <t hangText="Configuration Endpoint"><vspace blankLines="0"/> An endpoint used to read
              the Event Stream’s current configuration.</t>
            <t hangText="Status Endpoint"><vspace blankLines="0"/> An endpoint used to read the
              Event Stream’s current status.</t>
            <t hangText="Add Subject Endpoint"><vspace blankLines="0"/> An endpoint used to add
              subjects to an Event Stream.</t>
            <t hangText="Remove Subject Endpoint"><vspace blankLines="0"/> An endpoint used to
              remove subjects from an Event Stream.</t>
            <t hangText="Verification Endpoint"><vspace blankLines="0"/> An endpoint used to
              request the Event Transmitter transmit a Verification Event over the Event
              Stream.</t>
          </list></t>

        <t>An Event Transmitter MAY use the same URLs as endpoints for multiple streams, provided
          that the Event Transmitter has some mechanism through which they can identify the
          applicable Event Stream for any given request, e.g. from authentication credentials. The
          definition of such mechanisms is outside the scope of this specification.</t>

        <section anchor="status" title="Stream Status">
          <section anchor="reading-a-streams-status" title="Reading a Stream’s Status">
            <t>An Event Receiver checks the current status of an event stream by making an HTTP
              GET request to the stream’s Status Endpoint. On receiving a valid request the Event
              Transmitter responds with a 200 OK response containing a <xref target="RFC7159">JSON</xref>
              object with a single attribute <spanx style="verb">status</spanx>, whose string value 
              MUST have one of the following values:<list style="hanging">
                <t hangText="enabled"><vspace blankLines="0"/> The transmitter will transmit
                  events over the stream, according to the stream’s configured delivery
                  method.</t>
                <t hangText="paused"><vspace blankLines="0"/> The transmitter will not transmit
                  events over the stream. The transmitter will hold any events it would have
                  transmitted while paused, and will transmit them when the stream’s status
                  becomes <spanx style="verb">enabled</spanx>.</t>
                <t hangText="disabled"><vspace blankLines="0"/> The transmitter will not
                  transmit events over the stream, and will not hold any events for later
                  transmission.</t>
              </list></t>
            
            <t>The following is a non-normative example request to check an event stream’s
              status:</t>
            
            <figure title="Example: Check Stream Status Request" anchor="figstatusreq">
              <artwork><![CDATA[
GET /set/status HTTP/1.1
Host: transmitter.example.com
Authorization: Bearer eyJ0b2tlbiI6ImV4YW1wbGUifQo=
]]></artwork>
            </figure>
            
            <t>The following is a non-normative example response:</t>
            
            <figure title="Example: Check Stream Status Response" anchor="figstatusresp">
              <artwork><![CDATA[
HTTP/1.1 200 OK
Content-Type: application/json; charset=UTF-8
Cache-Control: no-store
Pragma: no-cache

{
  "status": "enabled"
}
]]></artwork>
            </figure>
          </section>
          
          <section anchor="updating-a-streams-status" title="Updating a Stream's Status">
            <t>An Event Receiver updates the current status of a stream by making an HTTP
              POST request to the Status Endpoint. The POST body contains a <xref target="RFC7159">JSON</xref>
              representation of the updated status. On receiving a valid request the Event
              Transmitter responds with a <spanx style="verb">200 OK</spanx> response containing a <xref target="RFC7159">JSON</xref>
              representation of the updated stream status in the body.</t>
            
            <t>The following is a non-normative example request to update an Event Stream’s
              status:</t>
            
            <figure title="Example: Update Stream Status Request"
              anchor="figupdatestatusreq">
              <artwork><![CDATA[
POST /set/status HTTP/1.1
Host: transmitter.example.com
Authorization: Bearer eyJ0b2tlbiI6ImV4YW1wbGUifQo=

{
  "status": "paused",
}
]]></artwork>
            </figure>
            
            <t>The following is a non-normative example response:</t>
            
            <figure title="Example: Update Stream Status Response"
              anchor="figupdatestatusresp">
              <artwork><![CDATA[
HTTP/1.1 200 OK
Content-Type: application/json; charset=UTF-8
Cache-Control: no-store
Pragma: no-cache

{
  "status": "paused",
}
]]></artwork>
            </figure>
            
            <t>Errors are signaled with HTTP staus codes as follows:</t>
            
            <texttable title="Update Stream Configuration Errors" anchor="tabupdatestatus">
              <ttcol align="left">Code</ttcol>
              <ttcol align="left">Description</ttcol>
              <c>400</c>
              <c>if the request body cannot be parsed or if the request is otherwise invalid</c>
              <c>401</c>
              <c>if authorization failed or it is missing</c>
              <c>403</c>
              <c>if the Event Receiver is not allowed to update the stream status</c>
            </texttable>
          </section>
        </section>
        
        <section anchor="stream" title="Stream Configuration">
          <t>An Event Stream’s configuration is represented as a <xref target="RFC7159">JSON</xref> object with
            the following properties:</t>

          <t><list style="hanging">
              <t hangText="aud"><vspace blankLines="0"/> A string containing an audience claim as
                defined in <xref target="RFC7519">JSON Web Token (JWT)</xref> that identifies the
                Event Receiver for the Event Stream. This property cannot be updated.</t>
              <t hangText="events_supported"><vspace blankLines="0"/> OPTIONAL. An array of URIs identifying
                the set of events supported by the Transmitter for this Receiver. If omitted, 
                Event Transmitters SHOULD make this set available to the Event Receiver via some 
                other means (e.g. publishing it in online documentation).</t>
            <t hangText="events_requested"><vspace blankLines="0"/> OPTIONAL. An array of URIs identifying
              the set of events that the Receiver requested. A Receiver should request only the events
              that it understands and it can act on. This is configurabel by the Receuver.</t>
            <t hangText="events_delivered"><vspace blankLines="0"/> OPTIONAL. An array of URIs 
              which is the intersection of <spanx style="verb">events_supported</spanx> and
              <spanx style="verb">events_requested</spanx>. These evebts MAY be delivered over 
              the Event Stream.</t>
            <t hangText="delivery"><vspace blankLines="0"/> A JSON object containing a set of
              name/value pairs specifying configuration parameters for the SET delivery method.
              The actual delivery method is identified by the special key <spanx style="verb">method</spanx> with
              the value being a URI as defined in <xref target="delivery-meta"/>.</t>
            <t hangText="min_verification_interval"><vspace blankLines="0"/> An integer
              indicating the minimum amount of time in seconds that must pass in between
              verification requests. If an Event Receiver submits verification requests more
              frequently than this, the Event Transmitter MAY respond with a 429 status code. An
              Event Transmitter SHOULD NOT respond with a 429 status code if an Event Receiver
              is not exceeding this frequency.</t>
            <t hangText="subject_type"> The Subject Identifier Type that the Receiver wants for the events.
              If not set then the Transmitter might decide to use a type that discloses more information
              than necessary.</t>
            </list></t>
          
          <section anchor="reading-a-streams-configuration"
            title="Reading a Stream’s Configuration">
            <t>An Event Receiver gets the current configuration of a stream by making an HTTP GET
              request to the Configuration Endpoint. On receiving a valid request the Event
              Transmitter responds with a <spanx style="verb">200 OK</spanx> response containing a <xref target="RFC7159">JSON</xref>
              representation of the stream’s configuration in the body.</t>

            <t>The following is a non-normative example request to read an Event Stream’s
              configuration:</t>

            <figure title="Example: Read Stream Configuration Request" anchor="figreadconfigreq">
              <artwork><![CDATA[
GET /set/stream HTTP/1.1
Host: transmitter.example.com
Authorization: Bearer eyJ0b2tlbiI6ImV4YW1wbGUifQo=
]]></artwork>
            </figure>

            <t>The following is a non-normative example response:</t>

            <figure title="Example: Read Stream Configuration Response" anchor="figreadconfigresp">
              <artwork><![CDATA[
HTTP/1.1 200 OK
Content-Type: application/json; charset=UTF-8
Cache-Control: no-store
Pragma: no-cache

{
  "aud": "http://www.example.com",
  "delivery": {
    "delivery_method": 
      "http://schemas.openid.net/secevent/risc/delivery-method/push",
    "url": "https://receiver.example.com/events",
  },
  "events_supported": [
    "urn:example:secevent:events:type_1",
    "urn:example:secevent:events:type_2",
    "urn:example:secevent:events:type_3",
  ],
  "events_requested": [
    "urn:example:secevent:events:type_2",
    "urn:example:secevent:events:type_3",
    "urn:example:secevent:events:type_4",
  ],
  "events_delivered": [
    "urn:example:secevent:events:type_2",
    "urn:example:secevent:events:type_3",
  ],
  "min_verification_interval": 60,
}
]]></artwork>
            </figure>

            <t>Errors are signaled with HTTP staus codes as follows:</t>

            <texttable title="Read Stream Configuration Errors" anchor="tabreadconfig">
              <ttcol align="left">Code</ttcol>
              <ttcol align="left">Description</ttcol>
              <c>401</c>
              <c>if authorization failed or it is missing</c>
              <c>403</c>
              <c>if the Event Receiver is not allowed to read the stream configuration</c>
              <c>404</c>
              <c>if there is no Event Stream configured for this Event Receiver</c>
            </texttable>
          </section>

          <section anchor="updating-a-streams-configuration"
            title="Updating a Stream’s Configuration">
            <t>An Event Receiver updates the current configuration of a stream by making an HTTP
              POST request to the Configuration Endpoint. The POST body contains a <xref target="RFC7159">JSON</xref>
              representation of the updated configuration. On receiving a valid request the Event
              Transmitter responds with a <spanx style="verb">200 OK</spanx> response containing a <xref target="RFC7159">JSON</xref>
              representation of the updated stream configuration in the body.</t>

            <t>The full set of editable properties must be present in the POST body, not only the
              ones that are specifically intended to be changed. Missing properties SHOULD be
              interpreted as requested to be deleted. Event Receivers should read the
              configuration first, modify the <xref target="RFC7159">JSON</xref> representation, then make an
              update request.</t>

            <t>Properties that cannot be updated MAY be present, but they MUST match the expected
              value.</t>

            <t>The following is a non-normative example request to update an Event Stream’s
              configuration:</t>

            <figure title="Example: Update Stream Configuration Request"
              anchor="figupdateconfigreq">
              <artwork><![CDATA[
POST /set/stream HTTP/1.1
Host: transmitter.example.com
Authorization: Bearer eyJ0b2tlbiI6ImV4YW1wbGUifQo=

{
  "aud": "http://www.example.com",
  "delivery": {
    "delivery_method":
      "http://schemas.openid.net/secevent/risc/delivery-method/push",
    "url": "https://receiver.example.com/events",
  },
  "events_requested": [
    "urn:example:secevent:events:type_2",
    "urn:example:secevent:events:type_3",
    "urn:example:secevent:events:type_4",
  ],
}
]]></artwork>
            </figure>

            <t>The following is a non-normative example response:</t>

            <figure title="Example: Update Stream Configuration Response"
              anchor="figupdateconfigresp">
              <artwork><![CDATA[
HTTP/1.1 200 OK
Content-Type: application/json; charset=UTF-8
Cache-Control: no-store
Pragma: no-cache

{
  "aud": "http://www.example.com",
  "delivery": {
    "delivery_method": 
      "http://schemas.openid.net/secevent/risc/delivery-method/push",
    "url": "https://receiver.example.com/events",
  },
  "events_supported": [
    "urn:example:secevent:events:type_1",
    "urn:example:secevent:events:type_2",
    "urn:example:secevent:events:type_3",
  ],
  "events_requested": [
    "urn:example:secevent:events:type_2",
    "urn:example:secevent:events:type_3",
    "urn:example:secevent:events:type_4",
  ],
  "events_delivered": [
    "urn:example:secevent:events:type_2",
    "urn:example:secevent:events:type_3",
  ],
}
]]></artwork>
            </figure>

            <t>Errors are signaled with HTTP staus codes as follows:</t>

            <texttable title="Update Stream Configuration Errors" anchor="tabupdateconfig">
              <ttcol align="left">Code</ttcol>
              <ttcol align="left">Description</ttcol>
              <c>400</c>
              <c>if the request body cannot be parsed or if the request is otherwise invalid</c>
              <c>401</c>
              <c>if authorization failed or it is missing</c>
              <c>403</c>
              <c>if the Event Receiver is not allowed to update the stream configuration</c>
            </texttable>

          </section>
        </section>
        <section anchor="subjects" title="Subjects">
          <t>An Event Receiver can indicate to an Event Transmitter whether or not the receiver
            wants to receive events about a particular subject by “adding” or “removing” that
            subject to the Event Stream, respectively.</t>

          <section anchor="adding-a-subject-to-a-stream" title="Adding a Subject to a Stream">
            <t>To add a subject to an Event Stream, the Event Receiver makes an HTTP POST request
              to the Add Subject Endpoint, containing in the body a Subject Identifier identifying
              the subject to be added. On a successful response, the Event Transmitter responds
              with an empty <spanx style="verb">200 OK</spanx> response.</t>

            <t>The Event Transmitter MAY choose to silently ignore the request, for example if the
              subject has previously indicated to the transmitter that they do not want events to
              be transmitted to the Event Receiver. In this case, the transmitter MAY return an
              empty <spanx style="verb">200 OK</spanx> response or an appropriate error code. See 
              <xref target="management-sec">Security Considerations</xref>.</t>

            <t>Errors are signaled with HTTP status codes as follows:</t>

            <texttable title="Add Subject Errors" anchor="tabadderr">
              <ttcol align="left">Code</ttcol>
              <ttcol align="left">Description</ttcol>
              <c>400</c>
              <c>if the request body cannot be parsed or if the request is otherwise invalid</c>
              <c>401</c>
              <c>if authorization failed or it is missing</c>
              <c>403</c>
              <c>if the Event Receiver is not allowed to add this particular subject</c>
              <c>404</c>
              <c>if the subject is not recognized by the Event Transmitter, the Event Transmitter
                may chose to stay silent in this case and respond with <spanx style="verb">200</spanx></c>
              <c>429</c>
              <c>if the Event Receiver is sending too many requests in a gvien amount of time</c>
            </texttable>

            <t>The following is a non-normative example request to add a subject to a stream,
              where the subject is identified by an Email Subject Identifier.</t>

            <figure title="Example: Add Subject Request" anchor="figaddreq">
              <artwork><![CDATA[
POST /set/subjects:add HTTP/1.1
Host: transmitter.example.com
Authorization: Bearer eyJ0b2tlbiI6ImV4YW1wbGUifQo=

{
  "subject_type": "email",
  "email": "example.user@example.com"
}
]]></artwork>
            </figure>

            <t>The following is a non-normative example response to a successful request:</t>

            <figure title="Example: Add Subject Response" anchor="figaddresp">
              <artwork><![CDATA[
HTTP/1.1 200 OK
Server: transmitter.example.com
Cache-Control: no-store
Pragma: no-cache
]]></artwork>
            </figure>

          </section>
          <section anchor="removing-a-subject" title="Removing a Subject">
            <t>To remove a subject from an Event Stream, the Event Receiver makes an HTTP POST
              request to the Remove Subject Endpoint, containing in the body a Subject Identifier
              identifying the subject to be removed. On a successful response, the Event
              Transmitter responds with a <spanx style="verb">204 No Content</spanx> response.</t>

            <t>Errors are signaled with HTTP staus codes as follows:</t>

            <texttable title="Remove Subject Errors" anchor="tabremoveerr">
              <ttcol align="left">Code</ttcol>
              <ttcol align="left">Description</ttcol>
              <c>400</c>
              <c>if the request body cannot be parsed or if the request is otherwise invalid</c>
              <c>401</c>
              <c>if authorization failed or it is missing</c>
              <c>403</c>
              <c>if the Event Receiver is not allowed to remove this particular subject</c>
              <c>404</c>
              <c>if the subject is not recognized by the Event Transmitter, the Event Transmitter
                may chose to stay silent in this case and respond with <spanx style="verb">204</spanx></c>
              <c>429</c>
              <c>if the Event Receiver is sending too many requests in a gvien amount of time</c>
            </texttable>

            <t>The following is a non-normative example request where the subject is identified by
              a Phone Number Subject Identifier:</t>

            <figure title="Example: Remove Subject Request" anchor="figremovereq">
              <artwork><![CDATA[
POST /set/subjects:remove HTTP/1.1
Host: transmitter.example.com
Authorization: Bearer eyJ0b2tlbiI6ImV4YW1wbGUifQo=

{
  "subject_type": "phone",
  "phone_number": "+1 206 555 0123"
}
]]></artwork>
            </figure>

            <t>The following is a non-normative example response to a successful request:</t>

            <figure title="Example: Remove Subject Response" anchor="figremoveresp">
              <artwork><![CDATA[
HTTP/1.1 204 No Content
Server: transmitter.example.com
Cache-Control: no-store
Pragma: no-cache
]]></artwork>
            </figure>

          </section>
        </section>
        <section anchor="verification" title="Verification">
          <t>In some cases, the frequency of event transmission on an Event Stream will be very
            low, making it difficult for an Event Receiver to tell the difference between expected
            behavior and event transmission failure due to a misconfigured stream. Event Receivers
            can request that a verification event be transmitted over the Event Stream, allowing
            the receiver to confirm that the stream is configured correctly upon successful
            receipt of the event. The acknowledgment of a Verification Event also confirms to the
            Event Transmitter that end-to-end delivery is working, including signature
            verification and encryption.</t>

          <t>An Event Transmitter MAY send a Verification Event at any time, even if one was not
            requested by the Event Receiver.</t>

          <section anchor="verification-event" title="Verification Event">
            <t>The Verification Event is a standard SET with the following attributes:</t>

            <t><list style="hanging">
                <t hangText="event type"><vspace blankLines="0"/> The Event Type URI is:
                  <spanx style="verb">http://schemas.openid.net/secevent/risc/event-type/verification</spanx>.</t>
                <t hangText="state"><vspace blankLines="0"/> OPTIONAL An opaque value provided by
                  the Event Receiver when the event is triggered. This is a nested attribute in
                  the event payload.</t>
              </list></t>

            <t>Upon receiving a Verification Event, the Event Receiver SHALL parse the SET and
              validate its claims. In particular, the Event Receiver SHALL confirm that the value
              for <spanx style="verb">state</spanx> is as expected. If the value of <spanx style="verb">state</spanx> does not match, an error
              response of <spanx style="verb">setData</spanx> SHOULD be returned (see Section 2.4 of <xref target="DELIVERY"/>).</t>

            <t>In many cases, Event Transmitters MAY disable or suspend an Event Stream that fails
              to successfully verify based on the acknowledgement or lack of acknowledgement by
              the Event Receiver.</t>

          </section>
          <section anchor="triggering-a-verification-event"
            title="Triggering a Verification Event.">
            <t>To request that a verification event be sent over an Event Stream, the Event
              Receiver makes an HTTP POST request to the Verification Endpoint, with a 
              <xref target="RFC7159">JSON</xref> object containing the parameters of the verification request,
              if any. On a successful request, the event transmitter responds with an empty 
              <spanx style="verb">204 No Content</spanx> response.</t>

            <t>Verification requests have the following properties:</t>

            <t><list style="hanging">
                <t hangText="state"><vspace blankLines="0"/> OPTIONAL. An arbitrary string that
                  the Event Transmitter MUST echo back to the Event Receiver in the verification
                  event’s payload. Event Receivers MAY use the value of this parameter to
                  correlate a verification event with a verification request. If the verification
                  event is initiated by the transmitter then this parameter MUST not be set.</t>
              </list></t>

            <t>A successful response from a POST to the Verification Endpoint does not indicate
              that the verification event was transmitted successfully, only that the Event
              Transmitter has transmitted the event or will do so at some point in the future.
              Event Transmitters MAY transmit the event via an asynchronous process, and SHOULD
              publish an SLA for verification event transmission times. Event Receivers MUST NOT
              depend on the verification event being transmitted synchronously or in any
              particular order relative to the current queue of events.</t>

            <t>Errors are signaled with HTTP staus codes as follows:</t>

            <texttable title="Verification Errors" anchor="taberifyerr">
              <ttcol align="left">Code</ttcol>
              <ttcol align="left">Description</ttcol>
              <c>400</c>
              <c>if the request body cannot be parsed or if the request is otherwise invalid</c>
              <c>401</c>
              <c>if authorization failed or it is missing</c>
              <c>429</c>
              <c>if the Event Receiver is sending too many requests in a gvien amount of time;
                see related <spanx style="verb">min_verification_interval</spanx> in <xref target="stream"/></c>
            </texttable>

            <t>The following is a non-normative example request to trigger a verification
              event:</t>

            <figure title="Example: Trigger Verification Request" anchor="figverifyreq">
              <artwork><![CDATA[
POST /set/verify HTTP/1.1
Host: transmitter.example.com
Authorization: Bearer eyJ0b2tlbiI6ImV4YW1wbGUifQo=
Content-Type: application/json; charset=UTF-8

{
  "state": "VGhpcyBpcyBhbiBleGFtcGxlIHN0YXRlIHZhbHVlLgo="
}
]]></artwork>
            </figure>

            <t>The following is a non-normative example response to a successful request:</t>

            <figure title="Example: Trigger Verification Response" anchor="figverifyresp">
              <artwork><![CDATA[
HTTP/1.1 204 No Content
Server: transmitter.example.com
Cache-Control: no-store
Pragma: no-cache
]]></artwork>
            </figure>

            <t>And the following is a non-normative example of a verification event sent to the
              Event Receiver as a result of the above request:</t>

            <figure title="Example: Verification SET" anchor="figverifyset">
              <artwork><![CDATA[
{
  "jti": "123456",
  "iss": "https://transmitter.example.com",
  "aud": "receiver.example.com",
  "iat": "1493856000",
  "events": [
    "http://schemas.openid.net/secevent/risc/event-type/verification":{
      "state": "VGhpcyBpcyBhbiBleGFtcGxlIHN0YXRlIHZhbHVlLgo=",
    },
  ],
}
]]></artwork>
            </figure>

          </section>
        </section>
      </section>

      <section anchor="management-api-auth" title="Authorization">
        <t>HTTP API calls from a receiver to a transmitter SHOULD be authorized using OAuth 2
          Access Tokens. The client id associated with the Access Token uniquely identifies the
          Receiver and the Stream.</t>
        
        <t>Receivers SHOULD use the <xref target="CLIENTCRED">Client Credential Grant</xref> to
          obtain access tokens on its own behalf.</t>
      </section>
      
      <section anchor="management-sec" title="Security Considerations">
        <section anchor="management-sec-subject-probing" title="Subject Probing">
          <t>It may be possible for an Event Transmitter to leak information about subjects
            through their responses to add subject requests. A <spanx style="verb">404</spanx> response may indicate to the
            Event Receiver that the subject does not exist, which may inadvertantly reveal
            information about the subject (e.g. that a particular individual does or does not use
            the Event Transmitter’s service).</t>

          <t>Event Transmitters SHOULD carefully evaluate the conditions under which they will
            return error responses to add subject requests. Event Transmitters MAY return a <spanx style="verb">204</spanx>
            response even if they will not actually send any events related to the subject, and
            Event Receivers MUST NOT assume that a 204 response means that they will receive
            events related to the subject.</t>

        </section>
        
        <section anchor="management-sec-information-harvesting" title="Information Harvesting">
          <t>SETs may contain personally identifiable information (PII) or other non-public
            information about the event transmitter, the subject (of an event in the SET), or the
            relationship between the two. It is important for Event Transmitters to understand
            what information they are revealing to Event Receivers when transmitting events to
            them, lest the event stream become a vector for unauthorized access to private
            information.</t>

          <t>Event Transmitters SHOULD interpret add subject requests as statements of interest in
            a subject by an Event Receiver, and ARE NOT obligated to transmit events related to
            every subject an Event Receiver adds to the stream. Event Transmitters MAY choose to
            transmit some, all, or no events related to any given subject and SHOULD validate that
            they are permitted to share the information contained within an event with the Event
            Receiver before transmitting the event. The mechanisms by which such validation is
            performed are outside the scope of this specification.</t>

        </section>
        
        <section anchor="management-sec-malicious-subject-removal" title="Malicious Subject Removal">
          <t>A malicious party may find it advantageous to remove a particular subject from a
            stream, in order to reduce the Event Receiver’s ability to detect malicious activity
            related to the subject, inconvenience the subject, or for other reasons. Consequently
            it may be in the best interests of the subject for the Event Transmitter to continue
            to send events related to the subject for some time after the subject has been removed
            from a stream.</t>

          <t>Event Transmitters MAY continue sending events related to a subject for some amount
            of time after that subject has been removed from the stream. Event Receivers MUST
            tolerate receiving events for subjects that have been removed from the stream, and
            MUST NOT report these events as errors to the Event Transmitter.</t>

        </section>
      </section>
    </section>

    <section anchor="profiles" title="Profiles">
      <t>This section profiles several IETF secevent specifications.</t>

      <t>The RISC Profile makes several assumptions:<list style="symbols">
          <t>Transmitters are Oauth 2 Authorization Servers</t>
          <t>Receivers are OAuth 2 Clients and as such have client ids issued by
            Transmitters</t>
        </list></t>

      <t>The RISC use cases that set the requirements are described in <xref target="USECASES"
          >Security Events RISC Use Cases</xref>.</t>

      <section anchor="set-profle" title="Security Event Token Profle">
        <t>This section provides RISC profiling specifications for the <xref target="SET">"Security
            Event Token (SET)"</xref> spec.</t>

        <section anchor="signature-key-resolution" title="Signature Key Resolution">
          <t>The signature key can be obtained through <spanx style="verb">jwks_uri</spanx>, see <xref target="discovery"/>.</t>
        </section>

        <section anchor="event-subjects" title="RISC Event Subject">
          <t>The subject of a RISC event is identified by the <spanx style="verb">subject</spanx> claim within the event
            payload, whose value is a Subject Identifier. The <spanx style="verb">subject</spanx> claim is REQUIRED for all
            RISC events. The JWT <spanx style="verb">sub</spanx> claim MUST NOT be present in any SET containing a RISC
            event.</t>
        </section>
        
        <section anchor="explicit-typing" title="Explicit Typing of SETs">
          <t>RISC events MUST use explicit typing as defined in Section 2.3 of <xref target="SET"/>.</t>
          
          <figure title="Explicitly Typed JOSE Header" anchor="explicit-type-header">
            <artwork><![CDATA[
{
  "typ":"secevent+jwt",
  "alg":"HS256"
}
]]></artwork>
          </figure>
          
          <t>The purpose is defense against confusion with other JWTs, as described in Sections
          4.5, 4.6 and 4.7 of <xref target="SET"/>. While current <xref target="IDTOKEN">Id Token</xref> validators may not
          be using the <spanx style="verb">typ</spanx> header parameter, by requiring it for RISC
          SETs a distinct value is guaranteed for future validators.</t>
        </section>
        
        <section anchor="exp-claim" title='The "exp" Claim'>
          <t>The <spanx style="verb">exp</spanx> claim MUST NOT be used in RISC SETs.</t>
          
          <t>The purpose is defense in depth against confusion with other JWTs, as described
          in Sections 4.5 and 4.6 of <xref target="SET"/>.</t>
        </section>

        <section anchor="aud" title="aud Claim">
          <t>The 'aud' claim MUST be a single value which is the client id of the Receiver.</t>
        </section>

        <section title="Security Considerations">
          <section title="Distingushing SETs from other Kinds of JWTs">
            <t>Of particular concern is the possibility that SETs are confused for other kinds
            of JWTs. The Security Considerations sesction of <xref target="SET"/> has several
            sub-sections on this subject. The RISC Profile is asking for further restrioctons:<list style="symbols">
              <t>The <spanx style="verb">sub</spanx> claim MUST NOT be present, as described
                in <xref target="event-subjects"/>.</t>
              <t>RISC SETs MUST use explicit typing, as described in <xref target="explicit-typing"/>.</t>
              <t>The <spanx style="verb">exp</spanx> claim MUST NOT be present, as described in 
              <xref target="exp-claim"/>.</t>
            </list></t>
          </section>
        </section>
      </section>

      <section anchor="set-token-delivery-using-http-profile"
        title="SET Token Delivery Using HTTP Profile">
        <t>This section provides RISC profiling specifications for the <xref target="DELIVERY">"SET
            Token Delivery Using HTTP"</xref> spec.</t>

        <section anchor="delivery-meta" title="Stream Configuration Metadata">
          <t>Each delivery method is identified by a URI, specified below by the 
            <spanx style="verb">method</spanx> metadata.</t>
          
          <section title="Push Delivery using HTTP">
            <t><list style="hanging">
              <t hangText="method"> <spanx style="verb">http://schemas.openid.net/secevent/risc/delivery-method/push</spanx></t>
              <t hangText="endpoint_url"> The URL where events are pushed through HTTP POST.
              This is set by the Receiver.</t>
              <t hangText="authorization_header">The HTTP Authorization header that the Transmitter MUST
              set with each event delivery, if the configuration is present. The value is optional and it is set by the Receiver.</t>
            </list></t>
          </section>
          
          <section title="Polling Delivery using HTTP">
            <t><list style="hanging">
              <t hangText="method"> <spanx style="verb">http://schemas.openid.net/secevent/risc/delivery-method/poll</spanx></t>
              <t hangText="endpoint_url"> The URL where events can be retrieved from. This is
              specified by the Transmitter.</t>
            </list></t>
          </section>
        </section>
      </section>
    </section>

    <section anchor="iana" title="IANA Considerations">
      <section anchor="iana-sub-id-types" title="RISC Subject Identifier Types Registry">
        <t>This section establishes the IANA "RISC Subject Identifier Types" registry for Subject
          Identifier Types. The registry records the name of the Subject Identifier Type and a
          reference to the specification that defines it. This section registers the Subject
          Identifier Types defined in <xref target="sub-id-types"/>.</t>

        <t>TODO: Finish registry definition</t>
      </section>
    </section>

    <section anchor="privacy" title="Privacy Considerations">
      <section anchor="sub-info-leakage" title="Subject Information Leakage">
        <t>Event issuers and recipients SHOULD take precautions to ensure that they do not leak
          information about subjects via Subject Identifiers, and choose appropriate Subject
          Identifier Types accordingly. Parties SHOULD NOT identify a subject using a given Subject
          Identifier Type if doing so will allow the recipient to correlate different claims about
          the subject that they are not known to already have knowledge of. Issuers and recipients
          SHOULD always use the same Subject Identifier Type and the same claim values to identify a
          given subject when communicating with a given party in order to reduce the possibility of
          information leakage.</t>
      </section>
    </section>
  </middle>

  <back>
    <references title="Normative References">

      <reference anchor="RFC7159" target="https://www.rfc-editor.org/info/rfc7159">
        <front>
          <title>The JavaScript Object Notation (JSON) Data Interchange Format</title>
          <author initials="T." surname="Bray" fullname="T. Bray" role="editor">
            <organization/>
          </author>
          <date year="2014" month="March"/>
          <abstract>
            <t>JavaScript Object Notation (JSON) is a lightweight, text-based, language-independent
              data interchange format. It was derived from the ECMAScript Programming Language
              Standard. JSON defines a small set of formatting rules for the portable representation
              of structured data.</t>
            <t>This document removes inconsistencies with other specifications of JSON, repairs
              specification errors, and offers experience-based interoperability guidance.</t>
          </abstract>
        </front>
        <seriesInfo name="RFC" value="7159"/>
        <seriesInfo name="DOI" value="10.17487/RFC7159"/>
      </reference>

      <reference anchor='RFC7517' target='https://www.rfc-editor.org/info/rfc7517'>
        <front>
          <title>JSON Web Key (JWK)</title>
          <author initials='M.' surname='Jones' fullname='M. Jones'><organization /></author>
          <date year='2015' month='May' />
          <abstract><t>A JSON Web Key (JWK) is a JavaScript Object Notation (JSON) data structure that represents a cryptographic key.  This specification also defines a JWK Set JSON data structure that represents a set of JWKs.  Cryptographic algorithms and identifiers for use with this specification are described in the separate JSON Web Algorithms (JWA) specification and IANA registries established by that specification.</t></abstract>
        </front>
        <seriesInfo name='RFC' value='7517'/>
        <seriesInfo name='DOI' value='10.17487/RFC7517'/>
      </reference>
      
      <reference anchor="RFC7519" target="https://www.rfc-editor.org/info/rfc7519">
        <front>
          <title>JSON Web Token (JWT)</title>
          <author initials="M." surname="Jones" fullname="M. Jones">
            <organization/>
          </author>
          <author initials="J." surname="Bradley" fullname="J. Bradley">
            <organization/>
          </author>
          <author initials="N." surname="Sakimura" fullname="N. Sakimura">
            <organization/>
          </author>
          <date year="2015" month="May"/>
          <abstract>
            <t>JSON Web Token (JWT) is a compact, URL-safe means of representing claims to be
              transferred between two parties. The claims in a JWT are encoded as a JSON object that
              is used as the payload of a JSON Web Signature (JWS) structure or as the plaintext of
              a JSON Web Encryption (JWE) structure, enabling the claims to be digitally signed or
              integrity protected with a Message Authentication Code (MAC) and/or encrypted.</t>
          </abstract>
        </front>
        <seriesInfo name="RFC" value="7519"/>
        <seriesInfo name="DOI" value="10.17487/RFC7519"/>
      </reference>

      <reference anchor="SECEVENT" target="https://datatracker.ietf.org/wg/secevent/about/">
        <front>
          <title>Security Events IETF Working Group</title>
          <author>
            <organization>IETF</organization>
          </author>
          <date/>
        </front>
      </reference>
      
      <reference anchor="SET" target="https://tools.ietf.org/html/draft-ietf-secevent-token">
        <front>
          <title>Security Event Token (SET)</title>
          <author>
            <organization>IETF</organization>
          </author>
          <date/>
        </front>
      </reference>

      <reference anchor="DELIVERY" target="https://tools.ietf.org/html/draft-ietf-secevent-delivery">
        <front>
          <title>SET Token Delivery Using HTTP</title>
          <author>
            <organization>IETF</organization>
          </author>
          <date/>
        </front>
      </reference>

      <reference anchor="MGMTAPI"
        target="https://tools.ietf.org/html/draft-scurtescu-secevent-simple-control-plane">
        <front>
          <title>Management API for SET Event Streams</title>
          <author>
            <organization>IETF</organization>
          </author>
          <date/>
        </front>
      </reference>

      <reference anchor="USECASES"
        target="https://tools.ietf.org/html/draft-scurtescu-secevent-risc-use-cases-00">
        <front>
          <title>Security Events RISC Use Cases</title>
          <author>
            <organization>IETF</organization>
          </author>
          <date/>
        </front>
      </reference>

      <reference anchor="CLIENTCRED" target="https://tools.ietf.org/html/rfc6749#section-4.4">
        <front>
          <title>The OAuth 2.0 Authorization Framework - Client Credentials Grant</title>
          <author initials="D." surname="Hardt" fullname="D. Hardt">
            <organization>Microsoft</organization>
          </author>
          <date/>
        </front>
        <seriesInfo name="RFC" value="6749"/>
      </reference>

      <reference anchor="IDTOKEN"
        target="http://openid.net/specs/openid-connect-core-1_0.html#IDToken">
        <front>
          <title>OpenID Connect Core 1.0 - ID Token</title>
          <author>
            <organization>OpenID Foundation</organization>
          </author>
          <date/>
        </front>
      </reference>

      <reference anchor="RFC2119" target="https://www.rfc-editor.org/info/rfc2119">
        <front>
          <title>Key words for use in RFCs to Indicate Requirement Levels</title>
          <author initials="S." surname="Bradner" fullname="S. Bradner">
            <organization/>
          </author>
          <date year="1997" month="March"/>
          <abstract>
            <t>In many standards track documents several words are used to signify the requirements
              in the specification. These words are often capitalized. This document defines these
              words as they should be interpreted in IETF documents. This document specifies an
              Internet Best Current Practices for the Internet Community, and requests discussion
              and suggestions for improvements.</t>
          </abstract>
        </front>
        <seriesInfo name="BCP" value="14"/>
        <seriesInfo name="RFC" value="2119"/>
        <seriesInfo name="DOI" value="10.17487/RFC2119"/>
      </reference>

      <reference anchor="E164" target="http://www.itu.int/rec/T-REC-E.164-201011-I/en">
        <front>
          <title>The international public telecommunication numbering plan</title>
          <author>
            <organization>International Telecommunication Union</organization>
          </author>
          <date year="2010"/>
        </front>
      </reference>
      
      <reference anchor="RFC5785" target="https://www.rfc-editor.org/info/rfc5785">
        <front>
          <title>Defining Well-Known Uniform Resource Identifiers (URIs)</title>
          <author initials="M." surname="Nottingham" fullname="M. Nottingham">
            <organization/>
          </author>
          <author initials="E." surname="Hammer-Lahav" fullname="E. Hammer-Lahav">
            <organization/>
          </author>
          <date year="2010" month="April"/>
          <abstract>
            <t>This memo defines a path prefix for "well-known locations",
              "/.well-known/", in selected Uniform Resource Identifier (URI)
              schemes.</t>
          </abstract>
        </front>
        <seriesInfo name="RFC" value="5785"/>
        <seriesInfo name="DOI" value="10.17487/RFC5785"/>
      </reference>
      
      <reference anchor="OIDC-DISCOVERY" target="https://openid.net/specs/openid-connect-discovery-1_0.html">
        <front>
          <title>OpenID Connect Discovery 1.0</title>
          <author fullname="Nat Sakimura" initials="N." surname="Sakimura">
            <organization abbrev="NRI">Nomura Research Institute, Ltd.</organization>
          </author>
          <author fullname="John Bradley" initials="J." surname="Bradley">
            <organization abbrev="Ping Identity">Ping Identity</organization>
          </author>
          <author fullname="Michael B. Jones" initials="M.B." surname="Jones">
            <organization abbrev="Microsoft">Microsoft</organization>
          </author>
          <author fullname="Edmund Jay" initials="E." surname="Jay">
            <organization abbrev="Illumila">Illumila</organization>
          </author>
          <date year="2014" month="November" day="8"/>
          <abstract>
            <t>This specification defines a mechanism for an OpenID Connect Relying Party to discover the End-User's
              OpenID Provider and obtain information needed to interact with it, including its OAuth 2.0 endpoint 
              locations.</t>
          </abstract>
        </front>
      </reference>
    </references>
    
    <section title="Acknowledgements" anchor="ack">
      <t><xref target="discovery">Transmitter Configuration Discovery</xref> is based on 
        <xref target="OIDC-DISCOVERY">OpenID Connect Discovery 1.0</xref>.</t>
    </section>
  </back>
</rfc>
